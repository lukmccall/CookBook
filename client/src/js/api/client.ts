/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.1.6.0 (NJsonSchema v10.0.28.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class Client {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterRequest | undefined): Promise<AuthSuccessResponse> {
        let url_ = this.baseUrl + "/api/v1/auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: Response): Promise<AuthSuccessResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthSuccessResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = AuthFailedResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = ValidationFailedResponse.fromJS(resultData422);
            return throwException("Client Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuthSuccessResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    login(body: LoginRequest | undefined): Promise<AuthSuccessResponse> {
        let url_ = this.baseUrl + "/api/v1/auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<AuthSuccessResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthSuccessResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = AuthFailedResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = ValidationFailedResponse.fromJS(resultData422);
            return throwException("Client Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuthSuccessResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    logout(body: LogoutRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/auth/logout";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogout(_response);
        });
    }

    protected processLogout(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = AuthFailedResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = ValidationFailedResponse.fromJS(resultData422);
            return throwException("Client Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    refresh(body: RefreshRequest | undefined): Promise<AuthSuccessResponse> {
        let url_ = this.baseUrl + "/api/v1/auth/refresh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRefresh(_response);
        });
    }

    protected processRefresh(response: Response): Promise<AuthSuccessResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthSuccessResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = AuthFailedResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = ValidationFailedResponse.fromJS(resultData422);
            return throwException("Client Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuthSuccessResponse>(<any>null);
    }

    /**
     * @return Success
     */
    recipePriceBreakdown(id: number): Promise<RecipesPriceBreakdownResponse> {
        let url_ = this.baseUrl + "/recipePriceBreakdown/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRecipePriceBreakdown(_response);
        });
    }

    protected processRecipePriceBreakdown(response: Response): Promise<RecipesPriceBreakdownResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            return throwException("Server Error", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Server Error", status, _responseText, _headers);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RecipesPriceBreakdownResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RecipesPriceBreakdownResponse>(<any>null);
    }

    /**
     * @return Success
     */
    recipeIngredients(id: number): Promise<RecipeIngredientsResponse> {
        let url_ = this.baseUrl + "/recipeIngredients/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRecipeIngredients(_response);
        });
    }

    protected processRecipeIngredients(response: Response): Promise<RecipeIngredientsResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            return throwException("Server Error", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Server Error", status, _responseText, _headers);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RecipeIngredientsResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RecipeIngredientsResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchByIngredients(body: IngredientsRequest | undefined): Promise<RecipeResponse[]> {
        let url_ = this.baseUrl + "/searchByIngredients";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchByIngredients(_response);
        });
    }

    protected processSearchByIngredients(response: Response): Promise<RecipeResponse[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            return throwException("Server Error", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Server Error", status, _responseText, _headers);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RecipeResponse.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RecipeResponse[]>(<any>null);
    }

    /**
     * @param stepBreakdown (optional) 
     * @return Success
     */
    recipeInstructions(id: number, stepBreakdown: boolean | undefined): Promise<RecipeInstructionResponse[]> {
        let url_ = this.baseUrl + "/recipeInstructions/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (stepBreakdown === null)
            throw new Error("The parameter 'stepBreakdown' cannot be null.");
        else if (stepBreakdown !== undefined)
            url_ += "stepBreakdown=" + encodeURIComponent("" + stepBreakdown) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRecipeInstructions(_response);
        });
    }

    protected processRecipeInstructions(response: Response): Promise<RecipeInstructionResponse[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            return throwException("Server Error", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Server Error", status, _responseText, _headers);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RecipeInstructionResponse.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RecipeInstructionResponse[]>(<any>null);
    }

    /**
     * @return Success
     */
    get(): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/users/me/get";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateCurrentUserRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/users/me/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangeCurrentUserPasswordRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/user/me/changePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangePassword(_response);
        });
    }

    protected processChangePassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param defaultCss (optional) 
     * @return Success
     */
    recipeVisualization(id: number, defaultCss: boolean | undefined): Promise<WidgetResponse> {
        let url_ = this.baseUrl + "/recipeVisualization/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (defaultCss === null)
            throw new Error("The parameter 'defaultCss' cannot be null.");
        else if (defaultCss !== undefined)
            url_ += "defaultCss=" + encodeURIComponent("" + defaultCss) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRecipeVisualization(_response);
        });
    }

    protected processRecipeVisualization(response: Response): Promise<WidgetResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WidgetResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            return throwException("Server Error", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Server Error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WidgetResponse>(<any>null);
    }

    /**
     * @param defaultCss (optional) 
     * @return Success
     */
    equipmentVisualization(id: number, defaultCss: boolean | undefined): Promise<WidgetResponse> {
        let url_ = this.baseUrl + "/equipmentVisualization/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (defaultCss === null)
            throw new Error("The parameter 'defaultCss' cannot be null.");
        else if (defaultCss !== undefined)
            url_ += "defaultCss=" + encodeURIComponent("" + defaultCss) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEquipmentVisualization(_response);
        });
    }

    protected processEquipmentVisualization(response: Response): Promise<WidgetResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WidgetResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            return throwException("Server Error", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Server Error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WidgetResponse>(<any>null);
    }

    /**
     * @param defaultCss (optional) 
     * @return Success
     */
    priceBreakdownVisualization(id: number, defaultCss: boolean | undefined): Promise<WidgetResponse> {
        let url_ = this.baseUrl + "/priceBreakdownVisualization/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (defaultCss === null)
            throw new Error("The parameter 'defaultCss' cannot be null.");
        else if (defaultCss !== undefined)
            url_ += "defaultCss=" + encodeURIComponent("" + defaultCss) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPriceBreakdownVisualization(_response);
        });
    }

    protected processPriceBreakdownVisualization(response: Response): Promise<WidgetResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WidgetResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            return throwException("Server Error", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Server Error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WidgetResponse>(<any>null);
    }

    /**
     * @param defaultCss (optional) 
     * @return Success
     */
    nutrionVisualization(id: number, defaultCss: boolean | undefined): Promise<WidgetResponse> {
        let url_ = this.baseUrl + "/nutrionVisualization/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (defaultCss === null)
            throw new Error("The parameter 'defaultCss' cannot be null.");
        else if (defaultCss !== undefined)
            url_ += "defaultCss=" + encodeURIComponent("" + defaultCss) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNutrionVisualization(_response);
        });
    }

    protected processNutrionVisualization(response: Response): Promise<WidgetResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WidgetResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            return throwException("Server Error", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Server Error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WidgetResponse>(<any>null);
    }
}

export class RegisterRequest implements IRegisterRequest {
    email!: string;
    userName!: string;
    password!: string;

    constructor(data?: IRegisterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.userName = _data["userName"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): RegisterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data; 
    }
}

export interface IRegisterRequest {
    email: string;
    userName: string;
    password: string;
}

export class AuthSuccessResponse implements IAuthSuccessResponse {
    token!: string;
    refreshToken!: string;
    success!: boolean;

    constructor(data?: IAuthSuccessResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.refreshToken = _data["refreshToken"];
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): AuthSuccessResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AuthSuccessResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["refreshToken"] = this.refreshToken;
        data["success"] = this.success;
        return data; 
    }
}

export interface IAuthSuccessResponse {
    token: string;
    refreshToken: string;
    success: boolean;
}

export class AuthFailedResponse implements IAuthFailedResponse {
    success!: boolean;
    errors!: string[];

    constructor(data?: IAuthFailedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.errors = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): AuthFailedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AuthFailedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IAuthFailedResponse {
    success: boolean;
    errors: string[];
}

export class FiledErrors implements IFiledErrors {
    field!: string;
    messages!: string[];

    constructor(data?: IFiledErrors) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.messages = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.field = _data["field"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(item);
            }
        }
    }

    static fromJS(data: any): FiledErrors {
        data = typeof data === 'object' ? data : {};
        let result = new FiledErrors();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item);
        }
        return data; 
    }
}

export interface IFiledErrors {
    field: string;
    messages: string[];
}

export class ValidationFailedResponse implements IValidationFailedResponse {
    readonly status!: boolean;
    errors!: FiledErrors[];

    constructor(data?: IValidationFailedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.errors = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).status = _data["status"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(FiledErrors.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ValidationFailedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationFailedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IValidationFailedResponse {
    status: boolean;
    errors: FiledErrors[];
}

export class LoginRequest implements ILoginRequest {
    email!: string;
    password!: string;

    constructor(data?: ILoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data; 
    }
}

export interface ILoginRequest {
    email: string;
    password: string;
}

export class LogoutRequest implements ILogoutRequest {
    token!: string;

    constructor(data?: ILogoutRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): LogoutRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LogoutRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        return data; 
    }
}

export interface ILogoutRequest {
    token: string;
}

export class RefreshRequest implements IRefreshRequest {
    token!: string;
    refreshToken!: string;

    constructor(data?: IRefreshRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): RefreshRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["refreshToken"] = this.refreshToken;
        return data; 
    }
}

export interface IRefreshRequest {
    token: string;
    refreshToken: string;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    readonly extensions?: { [key: string]: any; } | undefined;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
            if (_data["extensions"]) {
                (<any>this).extensions = {} as any;
                for (let key in _data["extensions"]) {
                    if (_data["extensions"].hasOwnProperty(key))
                        (<any>this).extensions![key] = _data["extensions"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        if (this.extensions) {
            data["extensions"] = {};
            for (let key in this.extensions) {
                if (this.extensions.hasOwnProperty(key))
                    data["extensions"][key] = this.extensions[key];
            }
        }
        return data; 
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    extensions?: { [key: string]: any; } | undefined;
}

export class MetricResponse implements IMetricResponse {
    unit?: string | undefined;
    value?: number;

    constructor(data?: IMetricResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.unit = _data["unit"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): MetricResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MetricResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unit"] = this.unit;
        data["value"] = this.value;
        return data; 
    }
}

export interface IMetricResponse {
    unit?: string | undefined;
    value?: number;
}

export class UsResponse implements IUsResponse {
    unit?: string | undefined;
    value?: number;

    constructor(data?: IUsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.unit = _data["unit"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): UsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unit"] = this.unit;
        data["value"] = this.value;
        return data; 
    }
}

export interface IUsResponse {
    unit?: string | undefined;
    value?: number;
}

export class AmountResponse implements IAmountResponse {
    metric?: MetricResponse;
    us?: UsResponse;

    constructor(data?: IAmountResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.metric = _data["metric"] ? MetricResponse.fromJS(_data["metric"]) : <any>undefined;
            this.us = _data["us"] ? UsResponse.fromJS(_data["us"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AmountResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AmountResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["metric"] = this.metric ? this.metric.toJSON() : <any>undefined;
        data["us"] = this.us ? this.us.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IAmountResponse {
    metric?: MetricResponse;
    us?: UsResponse;
}

export class IngredientsResponse implements IIngredientsResponse {
    amount?: AmountResponse;
    image?: string | undefined;
    name?: string | undefined;

    constructor(data?: IIngredientsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["amount"] ? AmountResponse.fromJS(_data["amount"]) : <any>undefined;
            this.image = _data["image"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): IngredientsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new IngredientsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount ? this.amount.toJSON() : <any>undefined;
        data["image"] = this.image;
        data["name"] = this.name;
        return data; 
    }
}

export interface IIngredientsResponse {
    amount?: AmountResponse;
    image?: string | undefined;
    name?: string | undefined;
}

export class RecipesPriceBreakdownResponse implements IRecipesPriceBreakdownResponse {
    ingredients?: IngredientsResponse[] | undefined;
    totalCost?: number;
    totalCostPerServing?: number;

    constructor(data?: IRecipesPriceBreakdownResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ingredients"])) {
                this.ingredients = [] as any;
                for (let item of _data["ingredients"])
                    this.ingredients!.push(IngredientsResponse.fromJS(item));
            }
            this.totalCost = _data["totalCost"];
            this.totalCostPerServing = _data["totalCostPerServing"];
        }
    }

    static fromJS(data: any): RecipesPriceBreakdownResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RecipesPriceBreakdownResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ingredients)) {
            data["ingredients"] = [];
            for (let item of this.ingredients)
                data["ingredients"].push(item.toJSON());
        }
        data["totalCost"] = this.totalCost;
        data["totalCostPerServing"] = this.totalCostPerServing;
        return data; 
    }
}

export interface IRecipesPriceBreakdownResponse {
    ingredients?: IngredientsResponse[] | undefined;
    totalCost?: number;
    totalCostPerServing?: number;
}

export class RecipeIngredientsResponse implements IRecipeIngredientsResponse {
    ingredients?: IngredientsResponse[] | undefined;

    constructor(data?: IRecipeIngredientsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ingredients"])) {
                this.ingredients = [] as any;
                for (let item of _data["ingredients"])
                    this.ingredients!.push(IngredientsResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RecipeIngredientsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RecipeIngredientsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ingredients)) {
            data["ingredients"] = [];
            for (let item of this.ingredients)
                data["ingredients"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IRecipeIngredientsResponse {
    ingredients?: IngredientsResponse[] | undefined;
}

export class IngredientsRequest implements IIngredientsRequest {
    ignorePantry?: boolean | undefined;
    limitLicense?: boolean | undefined;
    number?: number | undefined;
    ranking?: number | undefined;
    ingredients?: string[] | undefined;

    constructor(data?: IIngredientsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ignorePantry = _data["ignorePantry"];
            this.limitLicense = _data["limitLicense"];
            this.number = _data["number"];
            this.ranking = _data["ranking"];
            if (Array.isArray(_data["ingredients"])) {
                this.ingredients = [] as any;
                for (let item of _data["ingredients"])
                    this.ingredients!.push(item);
            }
        }
    }

    static fromJS(data: any): IngredientsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new IngredientsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ignorePantry"] = this.ignorePantry;
        data["limitLicense"] = this.limitLicense;
        data["number"] = this.number;
        data["ranking"] = this.ranking;
        if (Array.isArray(this.ingredients)) {
            data["ingredients"] = [];
            for (let item of this.ingredients)
                data["ingredients"].push(item);
        }
        return data; 
    }
}

export interface IIngredientsRequest {
    ignorePantry?: boolean | undefined;
    limitLicense?: boolean | undefined;
    number?: number | undefined;
    ranking?: number | undefined;
    ingredients?: string[] | undefined;
}

export class Ingredient implements IIngredient {
    aisle?: string | undefined;
    amount?: number;
    id?: number;
    image?: string | undefined;
    metaInformation?: string[] | undefined;
    name?: string | undefined;
    original?: string | undefined;
    originalName?: string | undefined;
    originalString?: string | undefined;
    unit?: string | undefined;
    unitLong?: string | undefined;
    unitShort?: string | undefined;

    constructor(data?: IIngredient) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.aisle = _data["aisle"];
            this.amount = _data["amount"];
            this.id = _data["id"];
            this.image = _data["image"];
            if (Array.isArray(_data["metaInformation"])) {
                this.metaInformation = [] as any;
                for (let item of _data["metaInformation"])
                    this.metaInformation!.push(item);
            }
            this.name = _data["name"];
            this.original = _data["original"];
            this.originalName = _data["originalName"];
            this.originalString = _data["originalString"];
            this.unit = _data["unit"];
            this.unitLong = _data["unitLong"];
            this.unitShort = _data["unitShort"];
        }
    }

    static fromJS(data: any): Ingredient {
        data = typeof data === 'object' ? data : {};
        let result = new Ingredient();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["aisle"] = this.aisle;
        data["amount"] = this.amount;
        data["id"] = this.id;
        data["image"] = this.image;
        if (Array.isArray(this.metaInformation)) {
            data["metaInformation"] = [];
            for (let item of this.metaInformation)
                data["metaInformation"].push(item);
        }
        data["name"] = this.name;
        data["original"] = this.original;
        data["originalName"] = this.originalName;
        data["originalString"] = this.originalString;
        data["unit"] = this.unit;
        data["unitLong"] = this.unitLong;
        data["unitShort"] = this.unitShort;
        return data; 
    }
}

export interface IIngredient {
    aisle?: string | undefined;
    amount?: number;
    id?: number;
    image?: string | undefined;
    metaInformation?: string[] | undefined;
    name?: string | undefined;
    original?: string | undefined;
    originalName?: string | undefined;
    originalString?: string | undefined;
    unit?: string | undefined;
    unitLong?: string | undefined;
    unitShort?: string | undefined;
}

export class RecipeResponse implements IRecipeResponse {
    id?: number;
    image?: string | undefined;
    imageType?: string | undefined;
    likes?: number;
    missedIngredientCount?: number;
    missedIngredients?: Ingredient[] | undefined;
    title?: string | undefined;
    unusedIngredients?: Ingredient[] | undefined;
    usedIngredientCount?: number;
    usedIngredients?: Ingredient[] | undefined;

    constructor(data?: IRecipeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.image = _data["image"];
            this.imageType = _data["imageType"];
            this.likes = _data["likes"];
            this.missedIngredientCount = _data["missedIngredientCount"];
            if (Array.isArray(_data["missedIngredients"])) {
                this.missedIngredients = [] as any;
                for (let item of _data["missedIngredients"])
                    this.missedIngredients!.push(Ingredient.fromJS(item));
            }
            this.title = _data["title"];
            if (Array.isArray(_data["unusedIngredients"])) {
                this.unusedIngredients = [] as any;
                for (let item of _data["unusedIngredients"])
                    this.unusedIngredients!.push(Ingredient.fromJS(item));
            }
            this.usedIngredientCount = _data["usedIngredientCount"];
            if (Array.isArray(_data["usedIngredients"])) {
                this.usedIngredients = [] as any;
                for (let item of _data["usedIngredients"])
                    this.usedIngredients!.push(Ingredient.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RecipeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RecipeResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["image"] = this.image;
        data["imageType"] = this.imageType;
        data["likes"] = this.likes;
        data["missedIngredientCount"] = this.missedIngredientCount;
        if (Array.isArray(this.missedIngredients)) {
            data["missedIngredients"] = [];
            for (let item of this.missedIngredients)
                data["missedIngredients"].push(item.toJSON());
        }
        data["title"] = this.title;
        if (Array.isArray(this.unusedIngredients)) {
            data["unusedIngredients"] = [];
            for (let item of this.unusedIngredients)
                data["unusedIngredients"].push(item.toJSON());
        }
        data["usedIngredientCount"] = this.usedIngredientCount;
        if (Array.isArray(this.usedIngredients)) {
            data["usedIngredients"] = [];
            for (let item of this.usedIngredients)
                data["usedIngredients"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IRecipeResponse {
    id?: number;
    image?: string | undefined;
    imageType?: string | undefined;
    likes?: number;
    missedIngredientCount?: number;
    missedIngredients?: Ingredient[] | undefined;
    title?: string | undefined;
    unusedIngredients?: Ingredient[] | undefined;
    usedIngredientCount?: number;
    usedIngredients?: Ingredient[] | undefined;
}

export class TemperatureResponse implements ITemperatureResponse {
    number?: number;
    unit?: string | undefined;

    constructor(data?: ITemperatureResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.number = _data["number"];
            this.unit = _data["unit"];
        }
    }

    static fromJS(data: any): TemperatureResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TemperatureResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["number"] = this.number;
        data["unit"] = this.unit;
        return data; 
    }
}

export interface ITemperatureResponse {
    number?: number;
    unit?: string | undefined;
}

export class EquipmentResponse implements IEquipmentResponse {
    id?: number;
    name?: string | undefined;
    temperature?: TemperatureResponse;

    constructor(data?: IEquipmentResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.temperature = _data["temperature"] ? TemperatureResponse.fromJS(_data["temperature"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EquipmentResponse {
        data = typeof data === 'object' ? data : {};
        let result = new EquipmentResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["temperature"] = this.temperature ? this.temperature.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IEquipmentResponse {
    id?: number;
    name?: string | undefined;
    temperature?: TemperatureResponse;
}

export class PhotoResponse implements IPhotoResponse {
    id?: number;
    image?: string | undefined;
    name?: string | undefined;

    constructor(data?: IPhotoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.image = _data["image"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): PhotoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PhotoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["image"] = this.image;
        data["name"] = this.name;
        return data; 
    }
}

export interface IPhotoResponse {
    id?: number;
    image?: string | undefined;
    name?: string | undefined;
}

export class StepInstructionReponse implements IStepInstructionReponse {
    equipment?: EquipmentResponse[] | undefined;
    ingredients?: PhotoResponse[] | undefined;
    number?: number;
    step?: string | undefined;

    constructor(data?: IStepInstructionReponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["equipment"])) {
                this.equipment = [] as any;
                for (let item of _data["equipment"])
                    this.equipment!.push(EquipmentResponse.fromJS(item));
            }
            if (Array.isArray(_data["ingredients"])) {
                this.ingredients = [] as any;
                for (let item of _data["ingredients"])
                    this.ingredients!.push(PhotoResponse.fromJS(item));
            }
            this.number = _data["number"];
            this.step = _data["step"];
        }
    }

    static fromJS(data: any): StepInstructionReponse {
        data = typeof data === 'object' ? data : {};
        let result = new StepInstructionReponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.equipment)) {
            data["equipment"] = [];
            for (let item of this.equipment)
                data["equipment"].push(item.toJSON());
        }
        if (Array.isArray(this.ingredients)) {
            data["ingredients"] = [];
            for (let item of this.ingredients)
                data["ingredients"].push(item.toJSON());
        }
        data["number"] = this.number;
        data["step"] = this.step;
        return data; 
    }
}

export interface IStepInstructionReponse {
    equipment?: EquipmentResponse[] | undefined;
    ingredients?: PhotoResponse[] | undefined;
    number?: number;
    step?: string | undefined;
}

export class RecipeInstructionResponse implements IRecipeInstructionResponse {
    name?: string | undefined;
    steps?: StepInstructionReponse[] | undefined;

    constructor(data?: IRecipeInstructionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["steps"])) {
                this.steps = [] as any;
                for (let item of _data["steps"])
                    this.steps!.push(StepInstructionReponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RecipeInstructionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RecipeInstructionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.steps)) {
            data["steps"] = [];
            for (let item of this.steps)
                data["steps"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IRecipeInstructionResponse {
    name?: string | undefined;
    steps?: StepInstructionReponse[] | undefined;
}

export class UpdateCurrentUserRequest implements IUpdateCurrentUserRequest {
    userName?: string | undefined;
    userSurname?: string | undefined;
    age?: number | undefined;
    description?: string | undefined;
    phoneNumber?: string | undefined;

    constructor(data?: IUpdateCurrentUserRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.userSurname = _data["userSurname"];
            this.age = _data["age"];
            this.description = _data["description"];
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): UpdateCurrentUserRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCurrentUserRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["userSurname"] = this.userSurname;
        data["age"] = this.age;
        data["description"] = this.description;
        data["phoneNumber"] = this.phoneNumber;
        return data; 
    }
}

export interface IUpdateCurrentUserRequest {
    userName?: string | undefined;
    userSurname?: string | undefined;
    age?: number | undefined;
    description?: string | undefined;
    phoneNumber?: string | undefined;
}

export class ChangeCurrentUserPasswordRequest implements IChangeCurrentUserPasswordRequest {
    oldPassword!: string;
    newPassword!: string;

    constructor(data?: IChangeCurrentUserPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.oldPassword = _data["oldPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangeCurrentUserPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeCurrentUserPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oldPassword"] = this.oldPassword;
        data["newPassword"] = this.newPassword;
        return data; 
    }
}

export interface IChangeCurrentUserPasswordRequest {
    oldPassword: string;
    newPassword: string;
}

export class WidgetResponse implements IWidgetResponse {
    code?: string | undefined;
    defaultCss?: boolean;

    constructor(data?: IWidgetResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.defaultCss = _data["defaultCss"];
        }
    }

    static fromJS(data: any): WidgetResponse {
        data = typeof data === 'object' ? data : {};
        let result = new WidgetResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["defaultCss"] = this.defaultCss;
        return data; 
    }
}

export interface IWidgetResponse {
    code?: string | undefined;
    defaultCss?: boolean;
}

export class ApiException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}